# Microcontroller Signoff
## FUNCTION OF THE SUBSYSTEM
	The microcontroller and its code are the centerpieces of the entire device.  They are responsible for operating, managing, communicating with, maintaining, and collaborating with all of the other subsystems and acts as both the brain and body of the device.  All the data and instructions must flow through the microcontroller at some point in its lifetime. This gives a common place for all of the data to go and be readily available for whichever subsystem has need of it.  The hardware will be responsible for the actual actions and completion of any given task. The code will be responsible for controlling the hardware and manipulating data.  This subsystem will be where most of the coding for the project is done as the operating code will be the largest by far.  The code itself will be where the “magic” happens as it allows for interfacing with the hardware and makes it more simple to utilize
	These jobs require a sufficiently powerful board.  One that has ample storage, plenty of physical space, decent processing power, sufficient support, and none restrictive.  Before choosing components and detailing the design, the specific constraints of the subsystem need to be known and laid out.  Then any potential solutions can be compared to the constraints to test viability and fulfillment of the subsystem’s purpose. 
## CONSTRAINTS ON THE SUBSYSTEM
	The subsystem constraints are placed to ensure that it can fulfill its job in a satisfactory manner.  The constraints given below are generalized to allow for comparison of any potential contender for the microcontroller.  Constraints on the subsystem are as follows:
1. The big job of the microcontroller will be to manage and operate the other subsystems to work cooperatively and synchronously.  This means that the board to be chosen must support fairly sophisticated code and be powerful enough to head all of the other subsystems.
2. The board should not take up a massive chunk of the budget.  With a budget of $300, a super-powered board is not affordable.  Preferably, the board price ranges between $20-$60.  This range is gathered from estimating the costs of other components and reasoning where money can be saved.
3. The board will need to support communication between different components. The other subsystems will be independent devices and require some way to cooperate.  The microcontroller must allow for the bridging of this gap to get information where it needs to go. To do this, Serial Peripheral Interface (SPI) will need to be achievable on the board.  SPI is a synchronous method of communication between two devices connected over a short distance.
4. For external storage to be possible, the microcontroller will need to be able to communicate and write to an external storage device.  On-board storage may be used for virtual memory, but the data itself must be placed in long-term storage externally to allow for manual retrieval/collection.  
5. A major goal of the project is to allow for synchronous operations of multiple air quality sensors.  This means that the board will need to have ample space and pins to accommodate at least 3 sensors simultaneously.  This can be either analog or digital signals.
6. Sensors may be either analog or digital, so there must be support for both.  Given that it is unknown what will be used on a case by case basis, the board must not be picky and needs to recognize what is being used and read in signals being given without being told which the sensor is.  This can be done by having at least 3 sets of designated pins for analog and digital signals.  
7. The cpu clock speed does not need to be very fast. The code will be mostly Input/Output heavy with less computation.  This means that there will be a lot of waiting for responses and does not require a high-speed processor.  Sampling rates can be done intermittently and still end with the same results as doing constant sampling.
8. There must be sufficient memory for the code.  It is unknown how big the code will be exactly.  The operating code will take up quite a bit of space in memory, so there needs to be adequate room.  A board with more RAM/SRAM/Flash/EEPROM than other comparable boards would be ideal.
9. A huge power-draw would mean that there needs to be a bigger power subsystem which could increase the cost to unacceptable levels.  The power requirements of the board need to be reasonable.
10. Some form of battery monitoring capabilities need to be included or applicable.  Telling the user how much longer the device may operate is a must.  This can be done using an additional component or algorithmic measurement.  The device will need to keep track of battery life to prevent data loss by saving and ceasing operations when reaching critical levels.  Doing this will ensure data protection.  
11. The board itself cannot be too big.  “Too big” here is defined as having a volume greater than 50 cubic inches.  This size was set to prevent the device from proving too large.  50 cubic inches would be about the size of a small novella/book.  .  
12. The manufacturer needs to be a reputable and safe choice.  Choosing a bad manufacturer could hurt the project.  A stable choice will lower the risk of receiving a malfunctioning board or running out of the specified board supply.  This device is planned to be open to public use and construction, so it will need to be trustworthy.
13. The board will need to have coding language support for assembly, C, and or Python.  It is expected that the users will have some degree of coding experience and may potentially personalize or improve upon the code. These languages are chosen due to popularity and performance.  C, in particular, is predicted to be very desirable for this project. 

Please refer to Wiki, image 1

## BUILDABLE SCHEMATIC OF SUBSYSTEM
	Shown is the pseudo-code for the operating code.  The final form of the code may have parts added and additional functionalities included, but this is the general idea of how the code should flow.  Proceeding from each section is assuming that there are no errors detected indicating a “Success”.  If an error arises, a default handler will need to be called to assess the situation.  It should also be noted that the loop is intended to be theoretically infinite, however, there are explicit and implicit breaks at the battery running critically low (explicit) and the shutoff button being pushed (implicit).  “Timers” refer to either physical hardware or coded timers that go off to alert the system that the sensor(s) sampling is ready.  Communication refers to the subsystem of the same name that handles wireless communications with the server.

##ANALYSIS OF CHOSEN COMPONENT(S)
	The team has chosen to look at the Arduino Mega 2560 Rev 3 and Arduino USB Shield Host as the solutions.  The Arduino Mega is a larger and more powerful version of the Arduino Uno, boasting much more storage, memory, and pin space.  The USB Shield is a breakout board or additional component that connects to the Arduino Mega to allow for USB devices to be implemented and utilized.  These components, in conjunction, will more than satisfy the constraints and jobs of this subsystem.  Following are the corresponding fulfillment of the constraints:
Arduino Mega is one of the bigger and more powerful Arduino products.  It has an astonishing 54 pin layout (4 of which are dedicated to hardware serial ports).  
For the ratio of money-to-power ratio, $48.40 (as of 11-8-22) is generous and will suffice.  This falls within the price range of $40 to $60 a little under the median.  The only fault here is the need for the USB Host Shield at a price of $20.99.  It is ultimately necessary to have some form of external storage available, but unfortunately, the Arduino Mega does not have a USB port by default.  This is an inconvenience, but the USB Host Shield does solve this problem for a bump in price and align with the specifications for the project.
The Arduino Mega comes with a set of designated communication pins that support UART and SPI communication.  SPI will allow for a smooth transfer of instructions and data between devices.  It also happens that Arduino comes with an SPI library already made and is open to the public for use.
The Arduino USB Host Shield will allow the Mega to accept USB devices for the purposes of external storage.  This will dramatically increase the storage capacity of the device and allow for easy manual retrieval of the data.  The USB device will simply need to be plugged into the port and then the Host Shield and Mega will handle the rest and notify the user when the device is safe to remove with all the data stored onto the USB storage.
The Arduino Mega almost flaunts its 54 pin layout for inputs/outputs.  With a workspace like this, there is no risk of running out of room later on and having to backtrack on what is possible to get done and cutting corners to make room.  The sensors themselves will only take a couple or triple of pins, so there will be support for plenty of sensors synchronously.  
In addition to the 54 digital pins, there are also 16 analog pins.  These pins are for input only, so that will be perfect for this subsystem’s needs.  The analog and digital sensors will both be able to be supported.  The assignment and designation of pins themselves will be decided further on in development, but there are no worries of needing more pins than we currently have whether they be analog or digital.
The clock speed is not very fast compared to a modern cpu, however, for a microcontroller, the Arduino Mega’s cpu clock runs at 16 MHz which is respectable.  A clock of this speed will easily run the code in more than satisfactory times as it is not computational heavy code.
The code is currently of an unknown size, so it is necessary to aim slightly higher in terms of needed processing memory.  With the Arduino Mega, it has 256 KB of Flash, 8 KB of SRAM, and 4 KB of EEPROM.  There are likely to be many included libraries that can quickly fill the processor's memory space which would greatly bog down operation times.  Having this amount of memory will put us in a safer position just in case the code is even bigger than expected.  
Running off a recommended voltage of 7-12 V but having a maximum range of 6-20 V gives some leeway on the power system as a bonus, but more importantly, it is, by default, not going to drain the battery at an alarming rate.  The board is rated to run at 20 mA and at a maximum current draw of 40 mA.  This should prove to not be too power hungry and help to meet some of the operational time specifications of the project.
Algorithmic measurement of the battery life is supported.  This is as in the board will be able to read the current/voltage levels coming from the battery and run an algorithm based on the battery’s expected output to determine the current capacity.
Psychically, the board is slightly bigger when compared to the other boards, but the extra space to support other components.  The board has a length of 101.52 mm and width of 53.3 mm.  This does put it below the volume cap.
Arduino is a very popular and respected manufacturing and electronics design company.  They have been around for a little while and have had a lot of support throughout the years.  It is expected for them to be around for quite a while.  The vast amount of online examples and support for Arduino projects alone is a huge bonus for choosing one of their products.  
The Arduino Mega supports C and Assembly for certain.  It could even be said that there is a favor for C when it comes to coding Arduino boards.  Arduino does have Python support as well and can potentially be used to accomplish the goals of this project or allow for the code to be translated from C to Python later on for whatever reason may arise from this team or another.  
	
	Arduino has been used for many, many projects in history and has a good track record.  The Arduino Mega and USB Host Shield have conjointly shown to fulfill the needs of this subsystem.  The hardware and software specifications are being checked off in their entirety and then some for potential wiggle room later in the project.  This gives more options and improvements later or prevents the need for cutting corners due to any restrictions that would arise from having a smaller and less powerful board.  Going with another option to save on the budget could prove to be a fatal flaw later on if the board doesn’t have enough room, memory, or power to get the job done.  Going a little extra seems reasonable and advisable. 

##BILL OF MATERIALS (BOM)

Please refer to Wiki, image 2

##SUBSYSTEM SCHEMATIC

Please refer to Wiki, image 3
